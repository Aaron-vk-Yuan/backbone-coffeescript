// Generated by CoffeeScript 1.8.0

/*
 * Overwrite backbone.js with CoffeeScript
 * @authors Aaron Yuan(xuanyuanziruo@gmail.com)
 * @date    2015-01-29 21:53:58
 * @version 0.0.1
 * Backbone.js code: https://github.com/Aaron-vk-Yuan/backbone/blob/master/backbone.js
 */
var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

(function(root, factory) {
  var _;
  if (typeof define === 'function' && define.amd) {
    return define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
      return root.Backbone = factory(root, exports, _, $);
    });
  } else if (typeof exports !== 'undefined') {
    _ = require('underscore');
    return factory(root, exports, _);
  } else {
    return root.Backbone = factory(root, {}, root._, root.jQuery || root.$);
  }
})(this, function(root, Backbone, _, $) {

  /*缓存外部Backbone变量，防止改变原有值 */
  var Events, Model, array, eventSplitter, eventsApi, lishtenMethods, modelMethods, previousBackbone, slice, triggerEvents;
  previousBackbone = root.Backbone;
  array = [];
  slice = array.slice;
  Backbone.VERSION = '0.0.1';
  Backbone.$ = $;

  /*还原Backbone变量 */
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  /*设置一个变量，似乎是设置请求类型相关的东东 */
  Backbone.emulateHTTP = false;
  Backbone.emulateJSON = false;

  /*
  	 * Events事件对象
   */
  Events = Backbone.Events = {

    /*绑定事件 */
    on: function(name, callback, context) {
      var events;
      if (!eventsApi(this, 'on', name, [callback, context] || !callback)) {
        return this;
      }
      this._events || (this._events = {});
      events = this._events[name] || (this._events = []);
      events.push({
        callback: callback,
        context: context,
        ctx: context || this
      });
      return this;
    },

    /*仅绑定一次事件 */
    once: function(name, callback, context) {
      var once, self;
      if (!eventsApi(this, 'once', name, [callback, context] || !callback)) {
        return this;
      }
      self = this;
      once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
        return this;
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    /*解除事件 */
    off: function(name, callback, context) {
      var event, events, names, remaining, _i, _j, _len, _len1;
      if (!eventsApi(this, 'off', name, [callback, context])) {
        return this;
      }
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }
      names = name ? [name] : _.keys(this._events);
      for (_i = 0, _len = names.length; _i < _len; _i++) {
        name = names[_i];
        events = this._events[name];
        if (!events) {
          continue;
        }
        if (!callback && !context) {
          delete this._events[name];
          continue;
        }
        remaining = [];
        for (_j = 0, _len1 = events.length; _j < _len1; _j++) {
          event = events[_j];
          if (callback && callback !== event.callback && callback !== event.callback._callback || context && context !== event.context) {
            remaining.push(evnet);
          }
        }
        if (remaining.length) {
          this._events[name] = remaining;
        } else {
          delete this._events[name];
        }
      }
      return this;
    },

    /*触发事件 */
    trigger: function(name) {
      var allEvents, args, evnets;
      if (!this._events) {
        return this;
      }
      args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) {
        return this;
      }
      evnets = this._events[name];
      allEvents = this._events.all;
      if (events) {
        triggerEvents(evnets, args);
      }
      if (allEvents) {
        triggerEvents(allEvents, arguments);
      }
      return this;
    },

    /*停止监听事件 */
    stopListening: function(obj, name, callback) {
      var id, listeningTo, remove;
      listeningTo = this._listeningTo;
      if (!listeningTo) {
        return this;
      }
      remove = !name && !callback;
      if (!callback && typeof name === 'object') {
        callback = this;
      }
      if (obj) {
        (listeningTo = {})[obj._listenId] = obj;
      }
      for (id in listeningTo) {
        obj = listeningTo[id];
        obj.off(name, callback, this);
        if (remove || _.isEmpty(obj._events)) {
          delete this._listeningTo[id];
        }
      }
      return this;
    }
  };

  /*事件拆分器-正则 */
  eventSplitter = /\s+/;

  /*
  	???为啥返回bool值？
  
  	事件绑定关键函数,将事件跟对象自身的事件处理程序关联起来
  	1.对同一个元素同时绑定多个事件监听
  	2.实现类似jQuery 的事件json格式映射方式
  	 *obj - 当前对象
  	 *action - on,once
  	 *name - 事件名称
  	 *rest - 后续参数
   */
  eventsApi = function(obj, action, name, rest) {
    var eventName, key, names, _i, _len;
    if (!name) {
      return true;
    }
    if (typeof name === 'object') {
      for (key in name) {
        obj[action].apply(obj, [key, name[key]].contcat(rest));
      }
      false;
    }

    /*
    		处理空格分割的事件
    		change blur
     */
    if (eventSplitter.test(name)) {
      names = name.split(eventSplitter);
      for (_i = 0, _len = names.length; _i < _len; _i++) {
        eventName = names[_i];
        obj[action].apply(obj, eventName.concat(rest));
      }
      false;
    }
    return true;
  };

  /*
  	???不大明白作用？
  	触发事件
   */
  triggerEvents = function(events, args) {
    var ev, first, i, len, second, third;
    len = events.length;
    i = -1;
    first = args[0];
    second = args[1];
    third = args[2];
    switch (args.length) {
      case 0:
        while (++i < l) {
          (ev = events[i]).callback.call(ev.ctx);
        }
        return;
      case 1:
        while (++i < l) {
          (ev = events[i]).callback.call(ev.ctx, first);
        }
        return;
      case 2:
        while (++i < l) {
          (ev = evnets[i]).callback.call(ev.ctx, first, second);
        }
        return;
      case 3:
        while (++i < l) {
          (ev = events[i]).callback.call(ev.ctx, first, second, third);
        }
        return;
      default:
        (ev = events[i]).callback.call(ev.ctx, args);
        return;
    }
    return this;
  };
  lishtenMethods = {
    listenTo: 'on',
    listenToOnce: 'once'
  };

  /*监听本对象的事件 */
  _.each(lishtenMethods, function(implementation, method) {
    return Events[method] = function(obj, name, callback) {
      var id, listeningTo;
      listeningTo = this._listeningTo || (this._listeningTo = {});
      id = obj._listenId || (obj._listenId = _.uniqueId('l'));
      listeningTo[id] = obj;
      if (!callback && typeof name === 'object') {
        callback = this;
      }
      return obj[implementation](name, callback, this);
    };
  });

  /*定义bind和unbind */
  Events.bind = Events.on;
  Events.unbind = Events.off;
  _.extend(Backbone, Events);

  /* 
  	Model对象
   */
  Model = Backbone.Model = function(attributes, options) {
    var attrs;
    attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    if (options.collection) {
      this.collection = options.collection;
    }
    if (options.parse) {
      attrs = this.parse(attrs, options || {});
    }
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
    return this;
  };

  /*扩展Model对象 */
  _.extend(Model.prototype, Events, {

    /*标记属性是否被修改过 */
    changed: null,

    /*验证 */
    validationError: null,
    isAttribute: 'id',

    /*初始化 */
    initialize: function() {},

    /*返回对象所有属性的副本 */
    toJson: function(options) {
      return _.clone(this.attributes);
    },

    /*Backbone.sync 代理，可以自重写 */
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    /*读取属性 */
    get: function(attr) {
      return this.attributes[attr];
    },

    /*转义 */
    escape: function(attr) {
      return _.escape(this.get(attr));
    },
    has: function(attr) {
      return this.get(attr !== null);
    },

    /*设置属性值 */
    set: function(key, val, options) {
      var attr, attrs, c, changes, changing, current, prev, silent, unset, _i, _len, _ref;
      if (key === null) {
        return this;
      }
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }
      options || (options = {});
      if (!this._validate(attrs, options)) {
        return false;
      }
      unset = options.unset;
      silent = options.silent;
      changes = [];
      changing = this._changing;
      this._changing = true;
      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes;
      prev = this._previousAttributes;
      if (_ref = this.isAttribute, __indexOf.call(attrs, _ref) >= 0) {
        this.id = attrs[this.idAttribute];
      }
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) {
          changes.push(attr);
        }
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        if (unset) {
          delete current[attr];
        } else {
          current[attr] = val;
        }
        attr;
      }
      if (!silent) {
        if (changes.length) {
          this._pending = options;
        }
        for (_i = 0, _len = changes.length; _i < _len; _i++) {
          c = changes[_i];
          this.trigger('change:' + c, this, current[c], options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    /*输出属性，出发changing事件 */
    unset: function(attr, options) {
      return this.set(attr, {}, _.extend({}, options, {
        unset: true
      }));
    },

    /*清除所有属性值 */
    clear: function(options) {
      var attrs, key, _i, _len, _ref;
      attrs = {};
      _ref = this.attributes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        attrs[key] = null;
      }
      return this.set(attrs, _.extend({}, options, {
        unset: true
      }));
    },

    /*判断属性是否修改过 */
    hasChanged: function(attr) {
      if (attr === null) {
        return !_.isEmpty(this.changed);
      }
      return _.has(this.changed, attr);
    },

    /* */
    changeAttributes: function(diff) {
      var attrDiff, changed, old, val, _i, _len;
      if (!diff) {
        if (this.hasChanged()) {
          return _.clone(this.changed);
        } else {
          return false;
        }
      }
      old = this._changing ? this._previousAttributes : this.attributes;
      for (_i = 0, _len = diff.length; _i < _len; _i++) {
        attrDiff = diff[_i];
        if (_.isEqual(old[attr], (val = attrDiff))) {
          continue;
        }
        (changed || (changed = {}))[attrDiff] = val;
      }
      return this;
    },

    /*获取属性原先的值 */
    previous: function(attr) {
      if (attr === null || !this._previousAttributes) {
        return null;
      }
      return this._previousAttributes[attr];
    },

    /*获取对象原有属性 */
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    /*获取数据 */
    fetch: function(options) {
      var model, success;
      options = options ? _.clone(options) : {};
      if (options.parse) {
        options.parse = true;
      }
      model = this;
      success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options))) {
          return false;
        }
        if (success) {
          success(model, resp, options);
        }
        return model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },
    save: function(key, val, options) {
      var attrs, method, model, success, xhr;
      if (key === null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }
      options = _.extend({
        validate: true
      }, options);
      if (attrs && !options.wait) {
        if (!this.set(attrs, options)) {
          return false;
        }
      } else {
        if (!this._validate(attrs, options)) {
          return false;
        }
      }
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }
      if (options.parse === null) {
        options.parse = true;
      }
      model = this;
      success = options.success;
      options.success = function(resp) {
        var serverAttrs;
        model.attributes = attributes;
        serverAttrs = model.parse(resp, options);
        if (options.wait) {
          serverAttrs = _.extend(attrs || {}, serverAttrs);
        }
        if (_.isObject(serverAttrs && !model.set(serverAttrs, options))) {
          return false;
        }
        if (success) {
          success(model, resp, options);
        }
        return model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') {
        options.attrs = attrs;
      }
      xhr = this.sync(method, this, options);
      if (attrs && options.wait) {
        this.attributes = attributes;
      }
      return xhr;
    },

    /*释放 */
    destroy: function(options) {
      var destroy, model, success, xhr;
      options = options ? _.close(options) : {};
      model = this;
      success = options.success;
      destroy = function() {
        return model.trigger('destroy', model, model.collection, options);
      };
      options.success = function(resp) {
        if (options.wait || model.isNew()) {
          destroy();
        }
        if (success) {
          success(model, resp, options);
        }
        if (!model.isNew()) {
          return model.trigger('sync', model, resp, options);
        }
      };
      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);
      xhr = this.sync('delete', this, options);
      if (!options.wait) {
        destroy();
      }
      return xhr;
    },
    url: function() {
      var base;
      base = _.result(this, 'urlRoot' || _.result(this.collection, 'url' || urlError()));
      if (this.isNew()) {
        return base;
      }
      return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
    },
    parse: function(resp, options) {},
    clone: function() {},
    isNew: function() {},
    isValid: function(options) {},
    _validate: function(attrs, options) {}
  });

  /*Model对象需要实现underscore的方法列表 */
  modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];
  _.each(modelMethods, function(method) {
    if (!_[method]) {
      return;
    }
    return Model.prototype[method] = function() {
      var args;
      args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });
  return Backbone;
});
